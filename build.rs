use std::env;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::Path;

#[derive(Debug, Clone, PartialEq)]
struct Type {
	signed: bool,
	size: u8,
	name: String,
}

impl Type {
	fn new(signed: bool, size: u8) -> Self {
		let name = if signed {
			format!("i{size}")
		} else {
			format!("u{size}")
		};

		Self { signed, size, name }
	}

	fn new_usize(word_size: u8) -> Self {
		Self {
			signed: false,
			size: word_size,
			name: "usize".to_string(),
		}
	}

	fn min(&self) -> i128 {
		if self.signed {
			let max_val = self.max();
			if max_val == i128::MAX {
				i128::MIN
			} else {
				-max_val
			}
		} else {
			0
		}
	}

	fn max(&self) -> i128 {
		let unsigned_size = self.unsigned_size();
		if unsigned_size >= 127 {
			i128::MAX
		} else {
			(1i128 << unsigned_size) - 1
		}
	}

	fn unsigned_size(&self) -> u8 {
		if self.signed {
			self.size - 1
		} else {
			self.size
		}
	}
}

fn generate_impl(
	writer: &mut BufWriter<File>,
	ty1: &Type,
	ty2: &Type,
	gate: Option<&str>,
) -> std::io::Result<()> {
	let max = std::cmp::max(
		ty2.max().saturating_sub(ty1.min()),
		ty1.max().saturating_sub(ty2.min()),
	);
	let output_min_size = (128 - max.leading_zeros()) as u8; // bit_length equivalent
	let len_min_size = if max == i128::MAX {
		128u8
	} else {
		(128 - (max + 1).leading_zeros()) as u8 // len type must store total elements
	};

	let len_size = [8u8, 16, 32, 64, 128]
		.iter()
		.find(|&&s| s >= len_min_size)
		.copied();

	let intermediate_signed = ty1.signed || ty2.signed;
	let intermediate_min_size = if intermediate_signed {
		output_min_size + 1
	} else {
		output_min_size
	};

	let intermediate_size = [8u8, 16, 32, 64, 128]
		.iter()
		.find(|&&s| s >= intermediate_min_size)
		.copied();

	if let (Some(intermediate_size), Some(len_size)) = (intermediate_size, len_size) {
		let intermediate_ty = Type::new(intermediate_signed, intermediate_size);
		let len_ty = Type::new(false, len_size);

		if let Some(gate) = gate {
			writeln!(writer, "{gate}")?;
		}

		if ty1 == ty2 {
			writeln!(
				writer,
				"impl_measure!(@refl {}, {}, {});",
				ty1.name, intermediate_ty.name, len_ty.name
			)?;
		} else {
			writeln!(
				writer,
				"impl_measure!(@both {}, {}, {}, {});",
				ty1.name, ty2.name, intermediate_ty.name, len_ty.name
			)?;
		}
	}

	Ok(())
}

fn main() -> std::io::Result<()> {
	let out_dir = env::var_os("OUT_DIR").unwrap();
	let dest_path = Path::new(&out_dir).join("generated_measures.rs");
	let file = File::create(&dest_path)?;
	let mut writer = BufWriter::new(file);

	// Create all the types
	let types = vec![
		Type::new(false, 8),   // u8
		Type::new(false, 16),  // u16
		Type::new(false, 32),  // u32
		Type::new(false, 64),  // u64
		Type::new(false, 128), // u128
		Type::new(true, 8),    // i8
		Type::new(true, 16),   // i16
		Type::new(true, 32),   // i32
		Type::new(true, 64),   // i64
		Type::new(true, 128),  // i128
	];

	writeln!(writer, "// This file is generated by build.rs")?;
	writeln!(writer, "// Do not edit manually")?;
	writeln!(writer)?;

	// Generate implementations for each type with itself
	for ty in &types {
		generate_impl(&mut writer, ty, ty, None)?;
	}

	// Generate implementations for all combinations of different types
	for i in 0..types.len() {
		for j in (i + 1)..types.len() {
			generate_impl(&mut writer, &types[i], &types[j], None)?;
		}
	}

	// Generate implementations for usize with different target pointer widths
	for word_size in [16u8, 32, 64] {
		let usize_ty = Type::new_usize(word_size);
		let gate = format!("#[cfg(target_pointer_width = \"{word_size}\")]");

		// usize with itself
		generate_impl(&mut writer, &usize_ty, &usize_ty, Some(&gate))?;

		// usize with all other types
		for ty in &types {
			generate_impl(&mut writer, &usize_ty, ty, Some(&gate))?;
		}
	}

	writer.flush()?;

	println!("cargo:rerun-if-changed=build.rs");

	Ok(())
}
