use core::{
	mem,
	ops::{Add, Sub},
};

#[cfg(feature = "nonzeroes")]
use core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8};

/// Distance between singletons.
#[allow(clippy::len_without_is_empty)]
pub trait Measure<Rhs: ?Sized = Self> {
	type Len: Default + Add<Output = Self::Len> + Sub<Output = Self::Len> + PartialEq;

	/// Returns the length of the given element.
	fn len(&self) -> Self::Len;

	/// Returns the distance to the given other element.
	fn distance(&self, other: &Rhs) -> Self::Len;
}

impl Measure for char {
	type Len = u64;

	fn len(&self) -> u64 {
		1
	}

	fn distance(&self, other: &char) -> u64 {
		let mut a = *self as u64;
		let mut b = *other as u64;

		if a > b {
			mem::swap(&mut a, &mut b);
		}

		if (..=0xd7ff).contains(&a) && (0xe000..).contains(&b) {
			(b - 0xd000 + 1) + (0xd7ff - a)
		} else {
			b - a
		}
	}
}

macro_rules! impl_measure {
	// Measure for type `$ty`.
	// `$cast` is a type that can handle the subtraction of two elements
	// without overflowing.
	// `$len` is a type that can handle the size of the entire domain of `$ty`.
	(@refl $ty:ty, $cast:ty, $len:ty) => {
		impl_measure!($ty, $ty, $cast, $len);
	};
	(@both $ty1:ty, $ty2:ty, $cast:ty, $len:ty) => {
		impl_measure!($ty1, $ty2, $cast, $len);
		impl_measure!($ty2, $ty1, $cast, $len);
	};
	($ty1:ty, $ty2:ty, $cast:ty, $len:ty) => {
		impl Measure<$ty2> for $ty1 {
			type Len = $len;

			fn len(&self) -> $len {
				1
			}

			fn distance(&self, other: &$ty2) -> $len {
				let a = *self as $cast;
				let b = *other as $cast;

				a.abs_diff(b) as $len
			}
		}
	};
}

// Generated by the build.rs script to avoid mistakes.
include!(concat!(env!("OUT_DIR"), "/generated_measures.rs"));

#[cfg(feature = "nonzeroes")]
macro_rules! impl_nonzero_measure {
	($ty:ty, $dist:ty) => {
		impl Measure<$ty> for $ty {
			type Len = $dist;

			fn len(&self) -> $dist {
				1
			}

			fn distance(&self, other: &$ty) -> $dist {
				self.get().abs_diff(other.get()) as $dist
			}
		}
	};
}

#[cfg(feature = "nonzeroes")]
impl_nonzero_measure!(NonZeroU8, u8);
#[cfg(feature = "nonzeroes")]
impl_nonzero_measure!(NonZeroU16, u16);
#[cfg(feature = "nonzeroes")]
impl_nonzero_measure!(NonZeroU32, u32);
#[cfg(feature = "nonzeroes")]
impl_nonzero_measure!(NonZeroU64, u64);
#[cfg(feature = "nonzeroes")]
impl_nonzero_measure!(NonZeroU128, u128);

macro_rules! impl_f_measure {
	($ty:ty, $zero:expr, $min:expr, $max:expr) => {
		impl Measure<$ty> for $ty {
			type Len = $ty;

			fn len(&self) -> $ty {
				$zero
			}

			fn distance(&self, other: &$ty) -> $ty {
				if self.is_infinite() || other.is_infinite() {
					$max
				} else {
					let a = *self as $ty;
					let b = *other as $ty;

					if a > b {
						(a - b) as $ty
					} else {
						(b - a) as $ty
					}
				}
			}
		}
	};
}

impl_f_measure!(f32, 0.0f32, f32::NEG_INFINITY, f32::INFINITY);
impl_f_measure!(f64, 0.0f64, f64::NEG_INFINITY, f64::INFINITY);

#[cfg(feature = "ordered-float")]
mod ordered_float {
	use super::Measure;
	use ordered_float::NotNan;

	impl_f_measure!(
		NotNan<f32>,
		unsafe { NotNan::new_unchecked(0.0f32) },
		unsafe { NotNan::new_unchecked(f32::NEG_INFINITY) },
		unsafe { NotNan::new_unchecked(f32::INFINITY) }
	);

	impl_f_measure!(
		NotNan<f64>,
		unsafe { NotNan::new_unchecked(0.0f64) },
		unsafe { NotNan::new_unchecked(f64::NEG_INFINITY) },
		unsafe { NotNan::new_unchecked(f64::INFINITY) }
	);
}
